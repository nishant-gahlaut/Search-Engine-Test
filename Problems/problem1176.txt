b'\nAll of you must have heard of merge sort while learning sorting algorithms. So, now is time to explore it more. Let us consider the following merge function in the merge sort algorithm: (Assume 1-base indexing)\n\nvoid merge(int a[], int b[], int n1, int n2, int c[])\n/* Function to merge the 2 arrays\na[1..n1] and b[1..n2] into array c[1..n1+n2] */\n{\n    int i = 1, j = 1, k = 1;\n    while (i <= n1 && j <= n2) {\n        if (a[i] <= b[j]) {  /* This is considered as 1 comparison */\n            c[k] = a[i];\n            i++;\n        }\n        else {\n            c[k] = b[j];\n            j++;\n        }\n        k++;\n    }\n    while (i <= n1) {\n        c[k] = a[i];\n        i++;\n        k++;\n    }\n    while (j <= n2) {\n        c[k] = b[j];\n        j++;\n        k++;\n    }\n}\n\nNow, in the function above, let us denote the maximum number of comparisons needed in the worst case while merging 2 arrays of sizes n1 and n2 as X. We are given M sorted arrays of size n1, n2, n3, ..., nM. To make a larger array of size n1 + n2 + n3 + ... + nM, you perform the following operation: \nIf only 1 array is left then stop.\nElse Pick any 2 sorted arrays and merge them using the above operation.\nAssume, that while merging any 2 arrays, it always takes worst case in the number of comparisons. You are required to minimise the number of comparison operations.\nInput\nThe first line in the input consists of the number of test cases, T. Each input consists of 2 lines. The first line contain an integer M, denoting the number of arrays. The second line consists of the sizes of arrays, n1, n2, n3, ... nM\nNOTE: The input dataset is large. Please prefer using scanf/printf in C/C++ and buffered I/O in Java.\nOutput\nOutput for each test case, the minimum number of comparisions while merging the M arrays into the final array.\nConstraints\n1 \xe2\x89\xa4 T \xe2\x89\xa4 20, 2 \xe2\x89\xa4 M \xe2\x89\xa4 105\n2 \xe2\x89\xa4 ni \xe2\x89\xa4 109\n\n                        Sample Input 1\n                        \n\n\n\n\n\n2\n2\n3 4\n3\n4 3 4\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n6\n16\n\n\nExplanation\nIn the first test case, the number of comparisons in worst case are 6. Consider for example, arrays a = {1, 6, 9} and b = {2, 5, 7, 8}. The comparisons are between the pair of elements (1, 2), (2, 6), (5, 6), (6, 7), (7, 9), (8, 9).\nIn the second test case, the best order to perform the merge operations is as follows. Merge the arrays with sizes 3 and 4 to obtain array of size 7. The number of comparisons in worst case is 6. Merge the arrays with sizes 4 and 7 to obtain array of size 11. The number of comparisons in worst case is 10. The total number of comparisons is 6 + 10 = 16\n\n\n\nAuthor:\n6\xe2\x98\x85likecs\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/ICL1704\n\n\nTags:\n\n               \n                 easy, icl2017, likecs, priority-queue\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n1901\n\n\nDate Added:\n26-03-2017\n\n\nTime Limit:\n2 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'