b'\nChef has a binary string S of length N.\nHe can perform the following operation on string S: \n\nSelect a substring of size M and flip all the characters of the selected substring, i.e., change 0 to 1 and 1 to 0.\n\nThere are Q queries of the following 2 types: \n\n0: Append 0 to the front of string S.\n1: Append 1 to the front of string S.\n\nAfter each query, find the minimum number of operations required to make lexicographically smallest possible string from S. Note that queries are dependent. Thus, after each query, the string S gets updated.\nNote: The input of this problem is large, so use fast input/output methods.\nInput Format\n\nThe first line will contain T - the number of test cases. Then the test cases follow.\nThe first line of each test case contains three integers N, M, and Q.\nThe second line of each test case contains the string S. \nAfter that, Q lines follow. The ith line contains an integer X (0\xe2\x89\xa4X\xe2\x89\xa41) - the ith query. For each query, you need to append X to the front of string S.\n\nOutput Format\nFor each test case, print Q lines. The ith line should contain the answer to the ith query.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa4105\n2\xe2\x89\xa4M\xe2\x89\xa4N\xe2\x89\xa4105\n1\xe2\x89\xa4Q\xe2\x89\xa4105\nSum of N over all test cases does not exceed 106.\nSum of Q over all test cases does not exceed 106.\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n1\n5 2 3\n10011\n1\n0\n1\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n2\n2\n5\n\n\nExplanation\nTest Case 1: Initially, S=10011. \n\nAfter the first query, S becomes 110011. The lexicographically minimum string into which S can be converted is 000000. The string 110011 can be converted to 000000 using 2 operations:\n\nOperation 1: Select the subarray [1,2] and flip it. Now, S becomes 000011.\nOperation 2: Select the subarray [5,6] and flip it. Now, S becomes 000000.\nIt can be proven that 110011 cannot be converted into 000000 in less than 2 operations.\nAfter the second query, S becomes 0110011. The lexicographically minimum string into which S can be converted is 0000000. The string 0110011 can be converted to 0000000 using 2 operations:\n\nOperation 1: Select the subarray [2,3] and flip it. Now, S becomes 0000011.\nOperation 2: Select the subarray [6,7] and flip it. Now, S becomes 0000000.\nIt can be proven that 0110011 cannot be converted into 0000000 in less than 2 operations.\nAfter the third query, S becomes 10110011. The lexicographically minimum string into which S can be converted is 00000001. The string 10110011 can be converted to 00000001 using 5 operations: These operations are [1,2], [2,3], [4,5], [5,6], and [6,7] in the given order.\nIt can be proven that S cannot be converted into a lexicographically smaller string than 00000001 using any number of operations.\nAlso, it can be proven that 10110011 cannot be converted into 00000001 in less than 5 operations.\n\n\n\n\nAuthor:\n7\xe2\x98\x85anript\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/BOP\n\n\nTags:\n\n               \n                 anript, bitwise-xor, discrete-maths, medium, start29\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n3294\n\n\nDate Added:\n26-02-2022\n\n\nTime Limit:\n3 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'