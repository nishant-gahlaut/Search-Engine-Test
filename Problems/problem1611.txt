b'\nJohn lives in a hilly city. He wants to go from point A to point B and he is planning to walk today. Fortunately for him, the city is designed like a grid. Unfortunately, as the elevation of each point is different, finding the easiest path is not trivial. That\xe2\x80\x99s why John needs your help.\n\nJohn wants to find a path from A to B with minimum hardness. Hardness of going from point A with height h_1 to adjacent point B with height h_2 is\n\n\n if h_1 > h_2, then 0.5 + 0.5 * sqrt(1 + (h_1 - h_2 )^2)\n otherwise, -0.5 + 1.5 * sqrt(1 + (h_1 - h_2 )^2)\n\n\nDistance between adjacent points is considered one unit. Slope of road segments between adjacent points is never more than 0.5.\n\nInput\nThe input file starts with a number T that represents the number of test cases. Then T test cases follow. Each test case starts with two number r, c, representing the size of the grid. Next r lines contain c numbers. j-th number from i-th line corresponds to the height of the intersection of i-th street with j-th avenue.\n\n\nNext line contains an integer q, then q lines follow. Each of the following lines represents a query. A query contains four numbers: i_s, j_s, i_e, and j_e. This represents a request to find the path with minimum hardness from intersection between i_s-th street and j_s-th avenue to the intersection between i_e-th street and j_e-th avenue.\n\nOutput\n\nStart each test case with case number as shown in sample output (e.g. \xe2\x80\x9cCase 1:\xe2\x80\x9d for the first case, quotes for clarification). Then output q lines, each for one query. For each query, output a line containing the hardness of optimal path with 6 digits after decimal point.\n\n\nSee sample input and output in the next page for details.\n\nConstraints\n1 <= T <= 10\n5 <= r, c <= 100\n1 <= q <= 100\n1 <= i_s, i_e <= r\n1 <= j_s, j_e <= c\nExample\nInput:\n2\n6 5\n0.0 0.1 0.2 0.3 0.4\n0.1 0.0 0.3 0.3 0.5\n0.2 0.2 0.2 0.2 0.2\n0.3 0.4 0.5 0.5 0.3\n0.3 0.5 0.5 0.5 0.6\n0.6 0.4 0.4 0.2 0.2 \n5\n1 1 4 4\n1 1 6 5\n1 1 1 5\n3 1 1 3\n6 5 2 3\n6 5\n0.0 0.1 0.2 0.3 0.4\n0.1 0.0 0.3 0.3 0.5\n0.2 0.2 0.2 0.2 0.2\n0.3 0.4 0.5 0.5 0.3\n0.3 0.5 0.5 0.5 0.6\n0.6 0.4 0.4 0.2 0.2 \n3\n1 5 6 1\n6 1 1 1\n6 3 2 5\n\n\nOutput:\nCase 1:\n6.037407\n9.049802\n4.029925\n4.009975\n6.066684\nCase 2:\n9.074374\n5.029497\n6.066684\n\n\n\nProblem Setter : Tanaeem Moosa\n\n\n\n\nAuthor:\njingbo_adm\n\n\nTags:\n\n               \n                 binary-heap, dijkstra-algorithm, jingbo_adm, kan13acm, medium\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\nN/A\n\n\nDate Added:\n2-12-2013\n\n\nTime Limit:\n0.62 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'