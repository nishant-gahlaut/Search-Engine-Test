b'\n Let S = s1, s2, ...,sn be a string and let S[i, j] denote the substring si, si+1, ... sj. The suffix array A of S is an array of integers giving the starting positions of suffixes of S in lexicographical order. This means, the entry A[i] contains the starting position of the i-th smallest(lexicographically) suffix of S. In other words, for all 1 < i \xe2\x89\xa4 n: S[A[i - 1], n] < S[A[i], n].\n\nLet us take an example. Suppose S = "12323". Then all suffixes of S are "12323", "2323", "323", "23", "3". If we sort the suffixes lexicographically, we get "12323", "23", "2323", "3", "323". Therefore the suffix array, which gives the starting positions of suffixes in lexicographic order, will be A = 1, 4, 2, 5, 3.\n\nThere is exactly one suffix array for each string. However, several strings can give the  same suffix array. In this problem, given a suffix array A of length N, you have to calculate the number of strings S whose suffix array is A.\n\nHowever, N can be very large, so the array A is not given directly. You should initialize the array A as A[i] = i for all 1 \xe2\x89\xa4 i \xe2\x89\xa4 N and apply M operations to it in order to obtain the desired suffix array A. Each operation can be of one of the following types:\n\n\n0 u v: Remove the sub-sequence A[u,v] and bring it to the front. After this operation, the N elements would be in the following order:  \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 A[u], A[u + 1], ...\nA[v], A[1], A[2], ... A[u - 1], A[v + 1], A[v + 2], ... A[N].\n\n1 u v: Flip A[u,v]. After this operation, the N elements would be in the following order:  \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 A[1], A[2], ... A[u-1], A[v], A[v-1], ... A[u+1], A[u], A[v+1], A[v+2], ... A[N].\n\n\n\n\nFor this problem, a string is an array of positive integers. Additionally, the number of different integers used in a string must be same as the largest integer in the string. For example: (1, 2, 2) and (4, 5, 1, 2, 3) are valid strings while (1, 1, 3) and (-1, 0, 1, 2) are not.\n\n\nSince the result can be extremely large, you just have to print it modulo 1,000,000,007(109 + 7) \n\nInput\nThe first line of the input contains 2 space separated integers, N and M. N is the length of suffix array, and M is the number of operations. \nEach of the next M lines contains 3 space separated integers representing an operation of one of the two types. \n\nOutput\n\nOutput a single line containing the number of strings corresponding to the given suffix array modulo 1,000,000,007(109 + 7) .\n\nConstraints\n\n1 \xe2\x89\xa4 N \xe2\x89\xa4 1,000,000,000 (109)\n0 \xe2\x89\xa4 M \xe2\x89\xa4 100,000 (105)\nFor all operations, 1 \xe2\x89\xa4 u \xe2\x89\xa4 v \xe2\x89\xa4 N\n\nExample\nInput:\n4 2\n1 2 3\n0 3 4\nOutput:\n4\n\nExplanation\n\nThe initial array is (1, 2, 3, 4).\nAfter the first operation the array becomes (1, 3, 2, 4). \nAfter the second operation the array becomes (2, 4, 1, 3).\nThe 4 possible strings are (2, 1, 2, 2), (2, 1, 3, 2), (3, 1, 3, 2), (3, 1, 4, 2).\n\n\n\n\nAuthor:\ntuan_adm\n\n\nTester:\n4\xe2\x98\x85keshav_57\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/TASUFFIX\n\n\nTags:\n\n               \n                 Suffix Arrays, Splay Tree\n                 \n                     \n                     Advanced Data Structures, Suffix Structures, Advanced Tree Structures\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n3393\n\n\nDate Added:\n15-05-2013\n\n\nTime Limit:\n5 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'