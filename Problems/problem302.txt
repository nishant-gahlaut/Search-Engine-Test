b'\nYou are given NN binary strings S1,S2,\xe2\x80\xa6,SNS1,S2,\xe2\x80\xa6,SN, each of length MM. You want to concatenate all the NN strings in some order to form a single large string of length N\xe2\x8b\x85MN\xe2\x8b\x85M. Find the minimum possible number of inversions the resulting string can have.\nA binary string is defined as a string consisting only of \'00\' and \'11\'.\nAn inversion in a binary string SS is a pair of indices (i,j)(i,j) such that i<ji<j and SiSi = \'11\', SjSj = \'00\'. For example, the string S=S= "0101001010" contains 33 inversions : (2,3)(2,3), (2,5),(2,5), (4,5)(4,5).\nNote that you are not allowed to change the order of characters within any of the strings SiSi - you are only allowed to concatenate the strings themselves in whatever order you choose. For example, if you have "0000" and "1010" you can form "00100010" and "10001000", but not "00010001".\nInput Format\n\nThe first line of input contains a single integer TT denoting the number of test cases. The description of TT test cases follows.\nThe first line of each test case contains two space-separated integers N,MN,M.\nNN lines follow, the ithith of which contains the string SiSi of length MM.\n\nOutput Format\nFor each test case, print a single line containing one integer - the minimum possible number of inversions in the resulting string.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa41031\xe2\x89\xa4T\xe2\x89\xa4103\n2\xe2\x89\xa4N\xe2\x89\xa41052\xe2\x89\xa4N\xe2\x89\xa4105\n1\xe2\x89\xa4M\xe2\x89\xa41051\xe2\x89\xa4M\xe2\x89\xa4105\n2\xe2\x89\xa4N\xe2\x8b\x85M\xe2\x89\xa42\xe2\x8b\x851052\xe2\x89\xa4N\xe2\x8b\x85M\xe2\x89\xa42\xe2\x8b\x85105\n|Si|=M|Si|=M\nSiSi contains only characters \'00\' and \'11\'.\nSum of N\xe2\x8b\x85MN\xe2\x8b\x85M over all test cases does not exceed 106106.\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n4\n2 1\n0\n1\n3 2\n10\n00\n01\n2 4\n0010\n1011\n3 4\n1011\n1101\n0101\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n0\n2\n3\n11\n\n\nExplanation\nTest case 11: Two strings can be formed : S1+S2=S1+S2="0101", S2+S1S2+S1= "1010". The first string does not have any inversion while the second has one inversion : (1,2)(1,2).\nTest case 22:  Both S2+S1+S3=S2+S1+S3="001001001001", S2+S3+S1=S2+S3+S1="000110000110" contain 22 inversions. It can be verified that no other order results in fewer inversions.\n\n\n\nAuthor:\n5\xe2\x98\x85soumyadeep_21\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/BININV\n\n\nTags:\n\n               \n                 String, Sorting, Observation\n                 \n                     \n                     Data Structures, Algorithms\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n1865\n\n\nDate Added:\n10-11-2021\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'