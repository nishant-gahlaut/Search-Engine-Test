b'\nGiven 33 string S1, S2 and X, find the number of non-empty substrings of X which can expressed as P+Q i.e. concatenation of strings P and Q, where P is some prefix of S1 (possibly empty) and Q is some prefix of S2 (possibly empty).\nA substring of a string is a contiguous subsequence of that string. For example, "chef" is a substring of "codechef", but "def" is not.\nA prefix of a string S is a substring of S that occurs at the beginning of S. For example, "code" is a prefix of "codechef", but "chef" is not. Also, an empty string is a prefix of any string.\nInput Format\n\nFirst line of the input contains T, the number of test cases. Then the test cases follow.\nEach test case contains three lines, string S1 in the first line, string S2 in the second line and string X in the third line. All strings consist of only lowercase Latin letters.\n\nOutput Format\nFor each test case, print a single line containing one integer denoting the number of substrings of X that satisfy the above conditions.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa4105\n1\xe2\x89\xa4|X|,|S1|,|S2|\xe2\x89\xa4106\nSum of |X| over all test cases doesn\'t exceed 106.\nSum of |S1| over all test cases doesn\'t exceed 106.\nSum of |S2| over all test cases doesn\'t exceed 106.\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n3\nab\nbc\nabc\naa\nbb\nab\naab\nacb\nbcaabacbc\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n5\n3\n10\n\n\nExplanation\nTest case 1:\nThere are 6 substrings of X=abc namely [a,b,c,ab,bc,abc].\n\nObserve that a is a prefix of S1=ab and an empty string is a prefix of S2=bc. By concatenating them, we get the string a.\nNow an empty string is a prefix of S1 and b is a prefix of S2. And by concatenating them, we get the string b.\nObserve that there is no prefix of S1 starting with c and also no prefix of S2 starting with c. So we cannot express the string c as a concatenation of prefixes.\nThe string ab is a prefix of S1 and an empty string is a prefix of S2. And by concatenation, we get ab.\nSimilarly, an empty string is a prefix of S1 and bc is a prefix of S2. And by concatenating them, we get bc.\nFinally, by taking the prefix a of S1 and the prefix bc of S2, we get abc when we concatenate them.\n\nSo all substrings of X except for the substring c can be expressed as a concatenation of some prefix of S1 and some prefix of S2. Therefore, the answer for this test case is 5.\nTest case 2:\nThere are 3 substrings of X=ab namely [a,b,ab].\n\nObserve that a is a prefix of S1=aa and an empty string is a prefix of S2=bb. By concatenating them, we get the string a.\nAn empty string is a prefix of S1 and b is a prefix of S2. And by concatenating them, we get the string b.\nFinally, by taking the prefix a of S1 and the prefix b of S2, we get ab when we concatenate them.\n\nSo all substrings of X can be expressed as a concatenation of some prefix of S1 and some prefix of S2. Therefore, the answer for this test case is 3.\n\n\n\nAuthor:\nsuryaprak_adm\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/SSTRPREF\n\n\nTags:\n\n               \n                 Sparse Table, Segment Trees, Pre processing, Z Algorithm, Range Minimum Queries\n                 \n                     \n                     Advanced Data Structures, Advanced Tree Structures, Advanced Algorithms, String Matching, Algorithms, Queries\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\nN/A\n\n\nDate Added:\n23-09-2021\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'