b"\nSuffix trees are very powerful data structures. Using suffix trees it's often easy to solve the hardest computer science problems on strings. In this problem we'll consider a simplified version of suffix trees -- suffix tries (that is, tries formed by all suffixes of a given string).\n\nGenerally, the suffix tree is a tree whose edges are labeled with strings. Instead, we'll only consider suffix tries whose edges are labeled with single characters. This way every edge of a suffix tree may correspond to one or more edges connected in a chain-style fashion of a suffix trie.\n\nAnother trait of suffix trees is that each suffix of the string for which the suffix tree is built corresponds to exactly one path from the tree's root to a leaf. This is usually achieved by terminating each suffix of the string with a special character, say, $. However, in suffix tries we won't do that. In particular, this implies that the number of leaves in a suffix trie can be smaller than the length of the original string.\n\nIn the picture the suffix tries for strings 'aba' and 'abac' are presented:\n\n\nIf we erase all letters from the edges of a suffix trie, it actually becomes a directed graph. Let's call two suffix tries equivalent if their corresponding directed graphs are isomorphic.\n\nYou're given a single string consisting of lowercase Latin letters. Your task is to find the number of different strings of the same length consisting of lowercase Latin letters as well such that their suffix tries are equivalent to the suffix trie of the given string. As this number can be large enough, output the remainder of its division by 42424242.\n\nInput\nThe first line contains a single number T -- the number of test cases (no more than 10). Each of the next T lines contains a single non-empty string of length no more than 100000 consisting of lowercase Latin letters a..z.\n\nOutput\nFor each test case output just one line containing the sought number modulo 42424242.\n\nExample\nInput:\n5\na\naa\nabc\naba\nhelloworld\n\nOutput:\n26\n26\n15600\n1300\n6221124\n\nExplanation:\n\nIn the first test case every string of length 1 satisfies the condition. In the second test case every string consisting of two equal letters is fine. In the third test case every string comprising three pairwise distinct letters adds 1 to the answer. In the fourth test case string 'bee' is one of the 1300 good strings.\n\n\n\nAuthor:\ngennady_adm\n\n\nTester:\n6\xe2\x98\x85laycurse\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/EST\n\n\nTags:\n\n               \n                 Suffix Trees, String Matching, Longest Common Prefix\n                 \n                     \n                     Advanced Data Structures, Suffix Structures, Advanced Algorithms, Algorithms, Dynamic Programming, DP on sequences\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2872\n\n\nDate Added:\n6-06-2012\n\n\nTime Limit:\n0.476583 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n"