b'\n Read problems statements in Mandarin Chinese  and Russian.\nSereja likes to generate pseudo random binary sequences. Now Sereja has two generators: one is a based on linear congruential generators (LCGs) and another is based on Xorshift.\nSereja has some binary sequences generated in past times, and he wants to know which generator makes these sequences. You can know the details of Sereja\'s generators, then can you answer this problem?\nThe following is the details. We may give the length N and a seed integer S to the generators, then they generate a binary sequence A[1], A[2], ..., A[N].\nThe 1st generator works as follows (C++ code. If you are not familiar with C++, please see the below section Notes for C++):\n/* ------------------ start here ---------------------*/\nunsigned X; // we assume that unsigned is a 32bit integer type\n\nvoid srand1(unsigned S){\n  X = S;\n}\n\nunsigned nextInteger1(void){\n  X = X * 1103515245 + 12345;\n  return (X / 65536) % 32768;\n}\n\nvoid generator1(int N, unsigned S, int A[]){\n  srand1(S);\n  for(int i=1;i<=N;i++){\n    A[i] = nextInteger1() % 2; \n  }\n}\n/* ------------------ end here -----------------------*/\n\n\n\nThe 2nd generator works as follows (C++ code):\n\n/* ------------------ start here ---------------------*/\nunsigned x, y, z, w; // we assume that unsigned is a 32bit integer type\n\nvoid srand2(unsigned S){\n  x = S;\n  y = x * S;\n  z = y * S;\n  w = z * S;\n}\n\nunsigned nextInteger2(void){\n  unsigned t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); \n}\n\nvoid generator2(int N, unsigned S, int A[]){\n  srand2(S);\n  for(int i=1;i<=N;i++){\n    A[i] = nextInteger2() % 2; \n  }\n}\n/* ------------------ end here -----------------------*/\n\n\nNote that the LCG used in the 1st generator is the same one suggested in ISO/IEC 9899 (pp. 346--347), and Xorshift used in the 2nd generator is the same one in the paper by Marsaglia (July 2003).\nInput\nThe first line of input contains an integer T, denoting the number of test cases. Then T test cases follow.\nEach test case has only one line. The line contains the string of length N, denoting the array A[1], A[2], ..., A[N], where the string consists of only characters \'0\' and \'1\', and the ith character denotes A[i].\nNote that the integer N is not given in the input explicitly.\nOutput\nFor each test case, print "LCG" if the given sequence generated by the 1st generator, or print "Xorshift" if the given sequence is generated by the 2nd generator.\nConstraints and Subtasks\n\n1 \xe2\x89\xa4 T \xe2\x89\xa4 30\nThere is no pair of integers (s, t) such that 0 \xe2\x89\xa4 s, t \xe2\x89\xa4 109 and both generator1(N, s, A) and generator2(N, t, A) generate the given sequence. (Thus the answer will be determined uniquely)\n\n\nSubtask 1 (10 points)\n\n\n50 \xe2\x89\xa4 N \xe2\x89\xa4 500\nThere is an integer 0 \xe2\x89\xa4 s \xe2\x89\xa4 500 such that generator1(N, s, A) or generator2(N, s, A) generates the given sequence.\n\n\n\nSubtask 2 (40 points)\n\n\n500 \xe2\x89\xa4 N \xe2\x89\xa4 100000\nThere is an integer 0 \xe2\x89\xa4 s \xe2\x89\xa4 31313 such that generator1(N, s, A) or generator2(N, s, A) generates the given sequence.\n\n\n\nSubtask 3 (20 points)\n\n\n100000 \xe2\x89\xa4 N \xe2\x89\xa4 200000\nThere is an integer 0 \xe2\x89\xa4 s \xe2\x89\xa4 109 such that generator1(N, s, A) or generator2(N, s, A) generates the given sequence.\n\n\n\nSubtask 4 (30 points)\n\n\n500 \xe2\x89\xa4 N \xe2\x89\xa4 200000\nThere is an integer 0 \xe2\x89\xa4 s \xe2\x89\xa4 109 such that generator1(N, s, A) or generator2(N, s, A) generates the given sequence.\n\nExample\nInput:\n6\n1101100100101111010011010101110100001000000101001110101011010101010\n000101101110101101110110010111000000011001101110101\n11010100010110001101010110111000010001110010010011011110010010110000001100110\n01011010100111100111101001010010100100111000111110\n0000000000000000000000001001001010101011001111101101010\n11101001010000000111101001111111000010000111010011111000001111\n\nOutput:\nLCG\nLCG\nLCG\nXorshift\nXorshift\nXorshift\n\nExplanation\nExample 1. generator1(67, 5, A) generates the given sequence.\nExample 2. generator1(51, 8, A) generates the given sequence.\nExample 3. generator1(77, 58, A) generates the given sequence.\nExample 4. generator2(50, 5, A) generates the given sequence.\nExample 5. generator2(55, 8, A) generates the given sequence.\nExample 6. generator2(62, 58, A) generates the given sequence.\nNotes for C++\n\nAt first, in the codes, almost every operation will be done with unsigned.\nThus operations will return the result modulo 232.\nFor example,\n\n    X * 1103515245 + 12345\n\n\nmeans that\n(X \xc3\x97 1103515245 + 12345) mod 232,\nand\n\n    (X / 65536) % 32768\n\n\nmeans that\n(floor(X / 65536) mod 32768) mod 232,\nin terms of mathematical notations.\n\n\nThen there are some bit operations in the 2nd generator.\nThe operators << and >> denote bit shifts.\nFor example,\n\n    X << 15\n\n\nmeans that\n(X \xc3\x97 215) mod 232,\nand\n\n    X >> 13\n\n\nmeans that\nfloor(X / 213).\nAnd the operator ^ denotes bitwise XOR.\n\n\n\n\nAuthor:\nsereja_adm\n\n\nTester:\n6\xe2\x98\x85laycurse\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/SEAPROAR\n\n\nTags:\n\n               \n                 Bitwise Operation, Observation\n                 \n                     \n                     Mathematics, Bit Manipulation, Algorithms\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2315\n\n\nDate Added:\n29-11-2014\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'