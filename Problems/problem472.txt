b"\nRead problem statements in Hindi, Bengali, Mandarin Chinese, Russian, and Vietnamese as well.\nAn encoder encodes the first 16 lowercase English letters using 4 bits each. The first bit (from the left) of the code is 0 if the letter lies among the first 8 letters, else it is 1, signifying that it lies among the last 8 letters. The second bit of the code is 0 if the letter lies among the first 4 letters of those 8 letters found in the previous step, else it's 1, signifying that it lies among the last 4 letters of those 8 letters. Similarly, the third and the fourth bit each signify the half in which the letter lies. \nFor example, the letter j would be encoded as :\n\nAmong (a,b,c,d,e,f,g,h | i,j,k,l,m,n,o,p), j appears in the second half. So the first bit of its encoding is 1.\nNow, among (i,j,k,l | m,n,o,p), j appears in the first half. So the second bit of its encoding is 0.\nNow, among (i,j | k,l), j appears in the first half. So the third bit of its encoding is 0.\nNow, among (i | j), j appears in the second half. So the fourth and last bit of its encoding is 1.\n\nSo j's encoding is 1001,\nGiven a binary encoded string S, of length at most 105, decode the string. That is, the first 4 bits are the encoding of the first letter of the secret message, the next 4 bits encode the second letter, and so on. It is guaranteed that the string's length is a multiple of 4.\nInput:\n\nThe first line of the input contains an integer T, denoting the number of test cases.\nThe first line of each test case contains an integer N, the length of the encoded string.\nThe second line of each test case contains the encoded string S.\n\nOutput:\nFor each test case, print the decoded string, in a separate line.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa410\n4\xe2\x89\xa4N\xe2\x89\xa4105\nThe length of the encoded string is a multiple of 4.\n0\xe2\x89\xa4Si\xe2\x89\xa41\n\nSubtasks\n\n100 points : Original constraints.\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n3\n4\n0000\n8\n00001111\n4\n1001\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\na\nap\nj\n\n\nExplanation\n\nSample Case 1 : \n\nThe first bit is 0, so the letter lies among the first 8 letters, i.e., among a,b,c,d,e,f,g,h. The second bit is 0, so it lies among the first four of these, i.e., among a,b,c,d. \nThe third bit is 0, so it again lies in the first half, i.e., it's either a or b. Finally, the fourth bit is also 0, so we know that the letter is a.\n\nSample Case 2 : \n\nEach four bits correspond to a character. Just like in sample case 1, 0000 is equivalent to a. Similarly, 1111 is equivalent to p. So, the decoded string is ap.\n\nSample Case 3 : \n\nThe first bit is 1, so the letter lies among the last 8 letters, i.e., among i,j,k,l,m,n,o,p. The second bit is 0, so it lies among the first four of these, i.e., among i,j,k,l. \nThe third bit is 0, so it again lies in the first half, i.e., it's either i or j. Finally, the fourth bit is 1, so we know that the letter is j.\n\n\n\nAuthor:\ndaanish_adm\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/DECODEIT\n\n\nTags:\n\n               \n                 Maps, Basic Maths, Binary, Observation, Brute Force, Implementation\n                 \n                     \n                     Data Structures, Mathematics, Number System, Algorithms\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\nN/A\n\n\nDate Added:\n31-12-2020\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n"