b'\n Read problems statements in Mandarin Chinese  and Russian.\nChef Hawlader and Chef Heickal are two good friends. Apart from cooking they also love algorithms. Chef Hawlader loves graph theory and Chef Heickal loves number theory.\nOnce again, Chef Hawlader is giving lecture to Chef Heickal about graph theory. "Hey Heickal, you should concentrate more on graph theory research. What remains in number theory? Graph is everything in the world, you can convert every problem to graph and solve them easily. Even your number theory problems can be converted and solved with graph theory, you know?" says Chef Hawlader. Though Chef Heickal does not hate graph, but according to his theory the life should a mixture of dynamic programming, number theory, data structure, ad hoc, graph theory, and so on. To become a good Chef you have to know all of them not just graph theory.\n\n"So are you master of graph? Do you know about DFS?" asks Chef Heickal.\n"Yes, of course. DFS, in full form Depth First Search, is a traversing or searching algorithm on graph. It\'s a basic algorithm", Chef Hawlader replied with angriness in his face.\n"Then, for a given graph, can you number each vertex using DFS in pre-order?" asks Chef Heickal again.\n"Too easy! It will be done by the following pseudo code:"\n\n\n\tint C = 1;\n\tvoid DFS(int u)\n\t{\n\t\tnew_number[u] = C;\n\t\tC++;\n\n\t\t// initially all value of visited array is set to false\n\t\tvisited[u] = true;\n\n\t\t// here v can be chosen in an arbitrary order\n\t\tfor each v such that there is a edge from u to v\n\t\t\tif(visited[v] == false) \n\t\t\t\tDFS(v);\n\t}\n\n\n\n"Okey, I can give you a hard problem", says Chef Heickal with evil smile.\n"What? Come on", replies Chef Hawlader with grinning face.\n"I\'ll give you a directed graph with N vertices and M edges. Here each vertex of the graph is numbered by DFS in pre-order. Of course, every vertex other than vertex 1 are reachable from vertex 1."\n"Okey, so what\'s problem?"\n"Wait, I give some definitions. A vertex x is a supreme vertex of y, if there is a directed path x = v0, v1, ..., vk = y, where x < y < vi for all 0 < i < k, that is a path from x to y with zero or more intermediate vertex vi and every intermediate vertex should be greater than x and y and x should be less than y. A vertex v is a superior vertex of w, if v is the minimum numbered vertex among all the supreme vertices of w. You will be given Q queries on the graph. On each query you will be given a vertex v, you have to find out how many vertices are there in the graph, which have vertex v as superior vertex."\n"Oh!! Duh!!"\n\nChef Hawlader could not solve the problem, he is asking you to solve it for him.\nInput\nThe first line of the input contains an integer T, denoting the number of test cases. Then T test cases follow.\nThe first line of each test contains three space-separated integers N, M, and Q. The ith line of the next M lines contains two space-separated integers Ui and Vi denoting the directed edge from vertex Ui to vertex Vi. The next line will contain Q space separated integers P1, P2, ..., PQ, denoting the queries defined above.\nOutput\nFor each test case, print a single line containing Q space-separated integers, denoting the answer of the Q queries according to the order of the input. If there is no superior vertex for a query, print 0. See the sample input and output for detailed format.\nConstraints\n\n1 \xe2\x89\xa4 T \xe2\x89\xa4 10\n2 \xe2\x89\xa4 N \xe2\x89\xa4 100000 (105)\nN \xe2\x88\x92 1 \xe2\x89\xa4 M \xe2\x89\xa4 200000 (2 \xc3\x97 105)\n1 \xe2\x89\xa4 Q \xe2\x89\xa4 100000 (105)\n1 \xe2\x89\xa4 Ui, Vi \xe2\x89\xa4 N, Ui \xe2\x89\xa0 Vi\nIf i \xe2\x89\xa0 j, then (Ui, Vi) \xe2\x89\xa0 (Uj, Vj)\n1 \xe2\x89\xa4 Pi \xe2\x89\xa4 N\nIn the given graph, the vertices 2, 3, ..., N are reachable from vertex 1\nThe vertices of the graph is numbered by DFS, denoted by the pseudo code in the statement\n\nExample\nInput:\n2\n3 3 3\n1 2\n1 3\n3 2\n1 2 3\n8 9 8\n1 2\n1 7\n2 3\n2 5\n3 4\n5 6\n7 8\n6 4\n8 4\n1 2 3 4 5 6 7 8\n\nOutput:\n2 0 0\n3 2 0 0 1 0 1 0\n\nExplanation\nExample case 1. Vertex 3 has only vertex 1 as supreme vertex as well as superior vertex because there is a direct edge from 1 to 3 and vertex 2 has a supreme vertex 1 (1 \xe2\x86\x92 3 \xe2\x86\x92  2). As vertex 2 has only one supreme vertex, it is the superior vertex also.\nExample case 2. Vertex 4 has three supreme vertices 1 (1 \xe2\x86\x92 7 \xe2\x86\x92 8 \xe2\x86\x92 4), 2 (2 \xe2\x86\x92 5 \xe2\x86\x92 6 \xe2\x86\x92 4) and 3 (3 \xe2\x86\x92 4). So vertex 1 is the superior vertex of 4.\n\n\n\nAuthor:\nshiplu_adm\n\n\nTester:\n6\xe2\x98\x85laycurse\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/DAGCH\n\n\nTags:\n\n               \n                 Segment Trees, HLD, Dominator\n                 \n                     \n                     Advanced Data Structures, Advanced Tree Structures, Advanced Algorithms, Advanced Graph Algos\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2770\n\n\nDate Added:\n12-12-2013\n\n\nTime Limit:\n2 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'