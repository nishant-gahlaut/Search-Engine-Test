b'\n\nAmortized analysis deals with analyzing the average amount of work done per operation over a series of operations. In some cases, the average amount of work done per operation is dramatically less than the worst case analysis indicates.\n\n\n\nA typical example is counting the number of times a bit is flipped in a ripple-carry counter. A ripple-carry counter is an implementation of a binary counter where incrementing from B to B+1 is done in the following manner. Say the binary number is represented as B = bn-1b_n-2...b_1b0 where bi is the bit corresponding to 2i. B is increased to B+1 in the following manner:\n\n\n\n\ni := 0\nwhile bi == 1\n   bi := 0\n   i := i+1\nbi := 1\n\n\n\nThis doesn\'t account for overflow when increasing from 2n-1 to 2n, but we\'ll ignore that error for this problem.\n\n\n\nEach time a bit is changed from 0 to 1 or from 1 to 0 we say the bit is "flipped". In the worst case, we may have to flip every bit. However, a standard result says the average number of bits flipped per increment when counting from 0 to 2n-1 is less than 2.\n\n\n\nBeing the curious sort, you decide to explore this result in a slightly more general setting. That is, you want to know how many bits are flipped when the counter is incremented from a number a to b where a < b. \n\n\nInput\n\nThe first line denotes the number of test cases (about 20).\n\n\n\nEach test case consists of three lines. The first contains a single integer n between 1 and 100,000 denoting the number of bits in the counter. The second line contains the number a written in binary and the third line contains the number b written in binary. Both a and b are described using exactly n bits.\n\n\nOutput\n\nThe output for each test case consists of a single line that describes the total number of bits flipped when the counter is increased from a to b. This number should be expressed in binary with the most significant bit being 1 (i.e. no leading zeros should pad the output).\n\n                        Sample Input 1\n                        \n\n\n\n\n\n3\n1\n0\n1\n2\n00\n11\n3\n011\n100\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n1\n100\n11\n\n\n\n\n\nAuthor:\nzac_adm\n\n\nTester:\n6\xe2\x98\x85pieguy\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/RIPPLE\n\n\nTags:\n\n               \n                 Bit Manipulation, ad-hoc, Observation\n                 \n                     \n                     Mathematics, Algorithms, Constructive\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2104\n\n\nDate Added:\n8-05-2010\n\n\nTime Limit:\n0.348837 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'