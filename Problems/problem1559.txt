b"\n\nChef's restaurant is the most attractive place to have dinner at. To understand why, let's have a look at a way customers do their orders:\n\n\nThere is only one list of N ingredients in the menu. Every ingredient has its beauty value that does not depend on its taste, but on the way it looks, which is expressed as a positive integer. To order a dish, the customer asks Chef to use all the ingredients from L to R (L is strictly less than R). Chef knows that the dish will be tasty and not only beautiful if the sum of its ingredients' beauty values is divisible by K. Chef does not want to use all the ingredients, so he always excludes one of them. Which one? - The least beautiful one! (in other words - which has the minimal beauty value). Now he wonders - how many segments (L,R) are there such that the sum of their beauty values will be divisible by K after excluding the least beautiful ingredient.\n\nInput:\nFirst line of the input consists of two positive integers - N and K. There are N space separated positive integers - beauty values of the ingredients.\nOutput:\nOutput should consist of a single integer - the answer for the problem. \nConstraints:\n1 \xe2\x89\xa4 N \xe2\x89\xa4 2*105\n1 \xe2\x89\xa4 K \xe2\x89\xa4 109\n1 \xe2\x89\xa4 beauty value \xe2\x89\xa4 109\n\nExample:\nInput:\n4 2\n1 2 3 4\n\nOutput:\n2\n\nScoring:\n1 \xe2\x89\xa4 N \xe2\x89\xa4 1000, this subtask is worth 21 point.\n1 \xe2\x89\xa4 K \xe2\x89\xa4 100, this subtask is worth 39 points.\nThere are no special constrains for the remaining 40 points.\nTest generation details: \n\nDelivery and sorting of ingredients is quite random thing, so all the test cases will look as follows:\nN and K are chosen by setter. An integer M is chosen by setter from interval [100..10^9]. Let B[] be the array of beauty values of ingredients. B[i] is chosen uniformly at random from an interval [1..M] for every 1 \xe2\x89\xa4 i \xe2\x89\xa4 N. After B[] is generated setter can choose a positive integer R and do B[i] = B[i]*R for every 1 \xe2\x89\xa4 i \xe2\x89\xa4 N. It's guaranteed that even after multiplying every B[i] won't exceed 10^9.\n\n\n\n\nAuthor:\nroman_adm\n\n\nTester:\n3\xe2\x98\x85vamsi_kavala\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/TASTYD\n\n\nTags:\n\n               \n                 Divide and Conquer\n                 \n                     \n                     Algorithms, Recursion\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2668\n\n\nDate Added:\n28-06-2013\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n"