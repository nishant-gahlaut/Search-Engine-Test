b"\nYour task is to write a program which computes exactly the same result as Chef's programs below. He was kind enough to provide you with the same program written in three different programming languages. However, your solution should be much faster.\nC++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring a, b, c;\n\tint na, nb, r;\n\tcin >> a;\n\tna = a.size();\n\tcin >> b;\n\tnb = b.size();\n\tcin >> c;\n\tr = 0;\n\tfor (int i = 0; i < nb; i++) {\n\t\tfor (int j = 1; j < min(na+1, nb-i+1); j++) {\n\t\t\tbool f = true;\n\t\t\tint d = 0;\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tif (a[k] != b[i+k]) { \n\t\t\t\t\tif (c[k] == '1')  { d += 1; }\n\t\t\t\t\telse { f = false; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f && d <= 2) { r = (r + j*j) % 1000000007; }\n\t\t}\n\t}\n\tcout << r << endl;\n\treturn 0;\n}\n\nJava\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic String a, b, c;\n\tstatic int na, nb, r;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\ta = sc.next();\n\t\tna = a.length();\n\t\tb = sc.next();\n\t\tnb = b.length();\n\t\tc = sc.next();\n\t\tr = 0;\n\t\tfor (int i = 0; i < nb; i++) {\n\t\t\tfor (int j = 1; j < Math.min(na+1, nb-i+1); j++) {\n\t\t\t\tboolean f = true;\n\t\t\t\tint d = 0;\n\t\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\t\tif (a.charAt(k) != b.charAt(i+k)) { \n\t\t\t\t\t\tif (c.charAt(k) == '1') { d += 1; }\n\t\t\t\t\t\telse { f = false; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f && d <= 2) { r = (r + j*j) % 1000000007; }\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n}\n\nPython\na = raw_input()\nna = len(a)\nb = raw_input()\nnb = len(b)\nc = raw_input()\nr = 0\nfor i in range(nb):\n\tfor j in range(1, min(na+1, nb-i+1)):\n\t\tf = True\n\t\td = 0\n\t\tfor k in range(j):\n\t\t\tif (a[k] != b[i+k]):\n\t\t\t\tif (c[k] == '1'): d +=1\n\t\t\t\telse: f = False\n\t\tif (f and d <= 2): r = (r + j*j) % 1000000007\nprint r\n\nInput\nThe strings A, B and C are provided in a compressed form to keep the input small enough. Sequence 00000 is encoded with letter 'a', 00001 with 'b' and so on until 'z'. 11010 is represented by 'A' and 11111 by 'F'.\nThe input consists of three lines of letters a-z, A-F. First line contains at most 200 characters and the second one at most 2 000 000. Third line has the same length as the first line and will contain at most 40 digits 1 when decompressed.\nExample\nInput:\naBFn\nygFBg\nbbdb\n\nOutput:\n2990\n\nExplanation\nAfter decompression we get strings 00000110111111101101, 1100000110111111101100110 and 00001000010001100001. If we run chef's program with this decompressed input, we will get 2990 as a result.\n            \n            \n            \n            \n            \n        \n\n        \n\n\nAuthor:\ntomaz_adm\n\n\nTester:\n6\xe2\x98\x85anton_lunyov\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/CYDB\n\n\nTags:\n\n               \n                 feb12, hard, tomaz_adm\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2594\n\n\nDate Added:\n4-12-2011\n\n\nTime Limit:\n0.334218 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n"